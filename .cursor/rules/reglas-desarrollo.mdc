---
alwaysApply: true
description: Reglas de desarrollo para React + Vite + Supabase, adaptadas de mejores pr√°cticas de Next.js y la comunidad React
globs: *.js,*.jsx,*.ts,*.tsx
---

# Reglas de Desarrollo - React + Vite + Supabase

Este documento adapta las mejores pr√°cticas de Next.js y la comunidad React a nuestro stack: **React 18 + Vite + Supabase + React Router + Tailwind CSS**.

## 1. Organizaci√≥n de C√≥digo y Estructura

### Estructura de Directorios

**‚ö†Ô∏è IMPORTANTE - Migraci√≥n a Atomic Design:**

- **C√≥digo nuevo**: Debe seguir la estructura de Atomic Design (ver secci√≥n 1.1)
- **C√≥digo existente**: Se mantiene en su ubicaci√≥n actual y se migrar√° progresivamente
- **No romper**: No mover componentes existentes hasta que se planifique su migraci√≥n

#### Estructura Actual (Legacy - Migraci√≥n Progresiva)

```
src/
‚îú‚îÄ‚îÄ components/        # Componentes existentes (se migrar√°n progresivamente)
‚îÇ   ‚îî‚îÄ‚îÄ ui/           # Componentes UI de shadcn (NO MODIFICAR directamente)
‚îú‚îÄ‚îÄ pages/            # P√°ginas/rutas de la aplicaci√≥n
‚îú‚îÄ‚îÄ contexts/          # Context providers (estado global)
‚îú‚îÄ‚îÄ hooks/            # Custom React hooks
‚îú‚îÄ‚îÄ integrations/     # Integraciones externas (Supabase)
‚îÇ   ‚îî‚îÄ‚îÄ supabase/    # Cliente y tipos de Supabase
‚îú‚îÄ‚îÄ lib/              # Utilidades y helpers
‚îú‚îÄ‚îÄ types/            # Tipos TypeScript compartidos
‚îú‚îÄ‚îÄ data/             # Datos mock y fixtures
‚îî‚îÄ‚îÄ assets/           # Im√°genes, fuentes, etc.
```

#### Estructura Nueva (Atomic Design - Para C√≥digo Nuevo)

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ atoms/        # ‚úÖ NUEVO: Componentes b√°sicos e indivisibles
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ui/      # Componentes UI de shadcn (NO MODIFICAR)
‚îÇ   ‚îú‚îÄ‚îÄ molecules/    # ‚úÖ NUEVO: Combinaciones simples de atoms
‚îÇ   ‚îú‚îÄ‚îÄ organisms/    # ‚úÖ NUEVO: Componentes complejos con l√≥gica
‚îÇ   ‚îî‚îÄ‚îÄ templates/    # ‚úÖ NUEVO: Layouts y estructuras de p√°gina
‚îú‚îÄ‚îÄ tokens/           # ‚úÖ NUEVO: Design tokens (colores, spacing, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ colors.ts
‚îÇ   ‚îú‚îÄ‚îÄ spacing.ts
‚îÇ   ‚îú‚îÄ‚îÄ typography.ts
‚îÇ   ‚îî‚îÄ‚îÄ shadows.ts
‚îú‚îÄ‚îÄ pages/            # P√°ginas/rutas de la aplicaci√≥n
‚îú‚îÄ‚îÄ contexts/         # Context providers (estado global)
‚îú‚îÄ‚îÄ hooks/            # Custom React hooks
‚îú‚îÄ‚îÄ integrations/     # Integraciones externas (Supabase)
‚îÇ   ‚îî‚îÄ‚îÄ supabase/    # Cliente y tipos de Supabase
‚îú‚îÄ‚îÄ lib/              # Utilidades y helpers
‚îú‚îÄ‚îÄ types/            # Tipos TypeScript compartidos
‚îú‚îÄ‚îÄ data/             # Datos mock y fixtures
‚îî‚îÄ‚îÄ assets/           # Im√°genes, fuentes, etc.
```

### Convenciones de Nombres de Archivos

- **Componentes**: `ComponentName.tsx` (PascalCase)
- **P√°ginas**: `PageName.tsx` (PascalCase)
- **Hooks**: `useHookName.ts` (camelCase, empieza con `use`)
- **Utilidades**: `utilityName.ts` (camelCase)
- **Tipos**: `types.ts` o `interfaces.ts` (kebab-case o descriptivo)
- **Constantes**: `constants.ts` (kebab-case)

### Organizaci√≥n de M√≥dulos

- **Co-locaci√≥n**: Mantener componentes, estilos y tests relacionados en el mismo directorio cuando sea apropiado
- **Atomic Design**: ‚úÖ **Usar para todo c√≥digo nuevo** - Ver secci√≥n 1.1
- **Evitar anidaci√≥n profunda**: Mantener la estructura relativamente plana para mejorar navegaci√≥n

## 1.1. Atomic Design - Sistema de Dise√±o

### ‚ö†Ô∏è Estrategia de Migraci√≥n

**A partir de ahora, TODO el c√≥digo nuevo debe seguir Atomic Design.**

- ‚úÖ **C√≥digo nuevo**: Crear en la estructura de Atomic Design
- üîÑ **C√≥digo existente**: Se mantiene donde est√°, migraci√≥n progresiva
- üö´ **No romper**: No mover componentes existentes sin planificaci√≥n

### ¬øQu√© es Atomic Design?

Atomic Design es una metodolog√≠a para construir sistemas de dise√±o de manera escalable y mantenible, organizando componentes en 5 niveles:

1. **Atoms** (√Åtomos): Componentes b√°sicos e indivisibles
2. **Molecules** (Mol√©culas): Combinaciones simples de atoms
3. **Organisms** (Organismos): Componentes complejos con l√≥gica
4. **Templates** (Plantillas): Layouts y estructuras de p√°gina
5. **Pages** (P√°ginas): Instancias espec√≠ficas de templates

### Estructura de Atomic Design

```
src/components/
‚îú‚îÄ‚îÄ atoms/              # Componentes b√°sicos e indivisibles
‚îÇ   ‚îú‚îÄ‚îÄ ui/           # shadcn components (Button, Input, Label, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ Icon.tsx      # Iconos reutilizables
‚îÇ   ‚îî‚îÄ‚îÄ Avatar.tsx    # Avatar b√°sico
‚îÇ
‚îú‚îÄ‚îÄ molecules/         # Combinaciones simples de atoms
‚îÇ   ‚îú‚îÄ‚îÄ SearchBar.tsx # Input + Button
‚îÇ   ‚îú‚îÄ‚îÄ PatientCard.tsx # Card + Avatar + Text
‚îÇ   ‚îî‚îÄ‚îÄ FormField.tsx # Label + Input + Error
‚îÇ
‚îú‚îÄ‚îÄ organisms/         # Componentes complejos con l√≥gica
‚îÇ   ‚îú‚îÄ‚îÄ PatientSelector.tsx # Selector con l√≥gica de pacientes
‚îÇ   ‚îú‚îÄ‚îÄ HealthProfile.tsx # Perfil de salud completo
‚îÇ   ‚îî‚îÄ‚îÄ ChatMessage.tsx # Mensaje de chat con l√≥gica
‚îÇ
‚îî‚îÄ‚îÄ templates/         # Layouts y estructuras de p√°gina
    ‚îú‚îÄ‚îÄ MobileLayout.tsx # Layout para m√≥vil
    ‚îî‚îÄ‚îÄ DashboardLayout.tsx # Layout de dashboard
```

### Reglas de Atomic Design

#### Atoms (√Åtomos)

- **Ubicaci√≥n**: `src/components/atoms/`
- **Caracter√≠sticas**:
  - Componentes b√°sicos e indivisibles
  - No tienen l√≥gica de negocio
  - Altamente reutilizables
  - Ejemplos: `Button`, `Input`, `Label`, `Icon`, `Avatar`

```typescript
// ‚úÖ Ejemplo: Atom
// src/components/atoms/Icon.tsx
import { LucideIcon } from 'lucide-react';

interface IconProps {
  icon: LucideIcon;
  size?: number;
  className?: string;
}

export const Icon = ({ icon: IconComponent, size = 20, className }: IconProps) => {
  return <IconComponent size={size} className={className} />;
};
```

#### Molecules (Mol√©culas)

- **Ubicaci√≥n**: `src/components/molecules/`
- **Caracter√≠sticas**:
  - Combinan 2-5 atoms
  - Pueden tener estado local simple
  - No tienen l√≥gica de negocio compleja
  - Ejemplos: `SearchBar`, `PatientCard`, `FormField`

```typescript
// ‚úÖ Ejemplo: Molecule
// src/components/molecules/SearchBar.tsx
import { Input } from '@/components/atoms/ui/input';
import { Button } from '@/components/atoms/ui/button';
import { Search } from 'lucide-react';

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSearch: () => void;
}

export const SearchBar = ({ value, onChange, onSearch }: SearchBarProps) => {
  return (
    <div className="flex gap-2">
      <Input value={value} onChange={(e) => onChange(e.target.value)} />
      <Button onClick={onSearch}>
        <Search />
      </Button>
    </div>
  );
};
```

#### Organisms (Organismos)

- **Ubicaci√≥n**: `src/components/organisms/`
- **Caracter√≠sticas**:
  - Componentes complejos con l√≥gica de negocio
  - Pueden usar hooks personalizados
  - Pueden hacer llamadas a APIs
  - Ejemplos: `PatientSelector`, `HealthProfile`, `ChatMessage`

```typescript
// ‚úÖ Ejemplo: Organism
// src/components/organisms/PatientSelector.tsx
import { useState, useEffect } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { supabase } from '@/integrations/supabase/client';
import { PatientCard } from '@/components/molecules/PatientCard';
import { Button } from '@/components/atoms/ui/button';

export const PatientSelector = () => {
  const { user } = useAuth();
  const [patients, setPatients] = useState([]);

  useEffect(() => {
    // L√≥gica de negocio aqu√≠
  }, [user]);

  return (
    <div>
      {patients.map(patient => (
        <PatientCard key={patient.id} patient={patient} />
      ))}
    </div>
  );
};
```

#### Templates (Plantillas)

- **Ubicaci√≥n**: `src/components/templates/`
- **Caracter√≠sticas**:
  - Layouts y estructuras de p√°gina
  - Definen la estructura, no el contenido
  - Pueden recibir slots para contenido
  - Ejemplos: `MobileLayout`, `DashboardLayout`

```typescript
// ‚úÖ Ejemplo: Template
// src/components/templates/MobileLayout.tsx
import { ReactNode } from 'react';
import { BottomNav } from '@/components/organisms/BottomNav';

interface MobileLayoutProps {
  children: ReactNode;
}

export const MobileLayout = ({ children }: MobileLayoutProps) => {
  return (
    <div className="flex flex-col min-h-screen">
      <main className="flex-1">{children}</main>
      <BottomNav />
    </div>
  );
};
```

### Design Tokens

Los design tokens est√°n definidos en variables CSS (`src/index.css`) y deben usarse a trav√©s de Tailwind. Ver secci√≥n completa de Design Tokens m√°s abajo.

### Migraci√≥n Progresiva a Atomic Design

**Plan de migraci√≥n:**

1. **Fase 1 (Actual)**: C√≥digo nuevo en Atomic Design, c√≥digo existente se mantiene
2. **Fase 2**: Identificar componentes candidatos para migraci√≥n
3. **Fase 3**: Migrar componentes cuando se necesiten cambios importantes
4. **Fase 4**: Limpiar estructura legacy cuando todos los componentes est√©n migrados

**No hacer:**
- ‚ùå Mover componentes existentes sin necesidad
- ‚ùå Romper imports existentes
- ‚ùå Migrar todo de una vez

**Hacer:**
- ‚úÖ Crear nuevos componentes en Atomic Design
- ‚úÖ Migrar cuando se necesite refactorizar
- ‚úÖ Actualizar imports gradualmente

### Checklist para Nuevos Componentes

Antes de crear un componente nuevo, preg√∫ntate:

1. **¬øEs un atom?** (Button, Input, Icon, Avatar) ‚Üí `components/atoms/`
2. **¬øEs una molecule?** (SearchBar, PatientCard, FormField) ‚Üí `components/molecules/`
3. **¬øEs un organism?** (PatientSelector, HealthProfile, ChatMessage) ‚Üí `components/organisms/`
4. **¬øEs un template?** (MobileLayout, DashboardLayout) ‚Üí `components/templates/`

**Regla de oro**: Si combinas 2+ componentes de un nivel inferior, pertenece al nivel superior.

**Ejemplo de decisi√≥n:**
- `Button` (solo) ‚Üí Atom
- `SearchBar` (Input + Button) ‚Üí Molecule
- `PatientSelector` (SearchBar + PatientCard + l√≥gica) ‚Üí Organism
- `MobileLayout` (estructura de p√°gina) ‚Üí Template

## 2. Arquitectura de Componentes

### Separaci√≥n de Responsabilidades

- **Componentes Presentacionales**: Solo renderizan UI, reciben props y callbacks
- **Componentes Container**: Manejan l√≥gica de negocio, data fetching y estado
- **Composici√≥n sobre herencia**: Favorecer composici√≥n para crear componentes flexibles

### Patrones de Dise√±o

- **Atomic Design**: ‚úÖ **OBLIGATORIO para c√≥digo nuevo** - Ver secci√≥n 1.1
- **Custom Hooks**: Extraer l√≥gica reutilizable a hooks personalizados
- **Context API**: Para estado global que no cambia frecuentemente
- **React Query**: Para data fetching y caching del servidor
- **Compound Components**: Combinar m√∫ltiples componentes que trabajan juntos

### Ejemplo de Estructura de Componente

```typescript
// ‚úÖ Estructura recomendada
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { useAuth } from '@/contexts/AuthContext';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

interface ComponentProps {
  title: string;
  onAction: () => void;
}

const MyComponent = ({ title, onAction }: ComponentProps) => {
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);

  // L√≥gica del componente
  const handleClick = async () => {
    setLoading(true);
    try {
      // Operaci√≥n async
      await onAction();
      toast.success('Operaci√≥n exitosa');
    } catch (error) {
      toast.error('Error en la operaci√≥n');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h1>{title}</h1>
      <Button onClick={handleClick} disabled={loading}>
        Acci√≥n
      </Button>
    </div>
  );
};

export default MyComponent;
```

## 3. Patrones Comunes y Anti-patrones

### Patrones Recomendados

#### Data Fetching

```typescript
// ‚úÖ Usar React Query para data fetching
import { useQuery, useMutation } from '@tanstack/react-query';

const { data, isLoading, error } = useQuery({
  queryKey: ['patients', userId],
  queryFn: () => fetchPatients(userId),
  staleTime: 5 * 60 * 1000, // 5 minutos
});

// ‚úÖ Para mutaciones
const mutation = useMutation({
  mutationFn: updatePatient,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['patients'] });
    toast.success('Paciente actualizado');
  },
});
```

#### Manejo de Estado

- **Estado Local**: `useState` para estado espec√≠fico del componente
- **Estado Global**: Context API para estado compartido (como `AuthContext`)
- **Estado del Servidor**: React Query para datos de Supabase
- **Formularios**: React Hook Form + Zod para validaci√≥n

#### Estilos y Design Tokens

- **Tailwind CSS**: Usar clases de Tailwind, evitar estilos inline
- **Utilidad `cn()`**: Para clases condicionales
- **Design Tokens**: Usar tokens definidos en `src/index.css` a trav√©s de Tailwind

##### Design Tokens Disponibles

Los tokens est√°n definidos como variables CSS en `src/index.css` y se acceden a trav√©s de clases de Tailwind:

**Colores:**
```typescript
// ‚úÖ Usar tokens de colores
<div className="bg-primary text-primary-foreground">
<div className="bg-secondary text-secondary-foreground">
<div className="bg-destructive text-destructive-foreground">
<div className="bg-muted text-muted-foreground">
<div className="bg-accent text-accent-foreground">
```

**Sombras:**
```typescript
// ‚úÖ Usar tokens de sombras
<div className="shadow-sm">   // --shadow-sm
<div className="shadow-md">   // --shadow-md
<div className="shadow-lg">   // --shadow-lg
<div className="shadow-xl">   // --shadow-xl
<div className="shadow-2xl">  // --shadow-2xl
```

**Radios:**
```typescript
// ‚úÖ Usar tokens de border radius
<div className="rounded-sm">  // calc(var(--radius) - 4px)
<div className="rounded-md">  // calc(var(--radius) - 2px)
<div className="rounded-lg"> // var(--radius)
```

**Fuentes:**
```typescript
// ‚úÖ Usar tokens de fuentes
<div className="font-sans">   // --font-sans (Inter)
<div className="font-serif"> // --font-serif (Lora)
<div className="font-mono">  // --font-mono (Space Mono)
```

**Variables CSS disponibles:**
- `--primary`, `--primary-foreground`
- `--secondary`, `--secondary-foreground`
- `--destructive`, `--destructive-foreground`
- `--muted`, `--muted-foreground`
- `--accent`, `--accent-foreground`
- `--background`, `--foreground`
- `--card`, `--card-foreground`
- `--border`, `--input`, `--ring`
- `--shadow-*` (sm, md, lg, xl, 2xl)
- `--radius`
- `--font-sans`, `--font-serif`, `--font-mono`

### Anti-patrones y Code Smells

‚ùå **NO HACER:**

- **Over-fetching**: Solo obtener datos necesarios
- **Mutaci√≥n directa de estado**: Siempre usar `setState` o hooks
- **No memoizar componentes pesados**: Usar `React.memo` cuando sea necesario
- **`useEffect` sin dependencias correctas**: Asegurar que el array de dependencias est√© completo
- **C√≥digo de servidor en componentes cliente**: Puede exponer secretos
- **Console.log en producci√≥n**: Eliminar antes de hacer commit
- **Tipos `any`**: Evitar, usar tipos espec√≠ficos o `unknown`

‚úÖ **HACER:**

- Validar datos en cliente Y servidor (Supabase RLS)
- Manejar errores apropiadamente
- Limpiar suscripciones y timers en `useEffect`
- Usar TypeScript estrictamente
- Probar componentes localmente antes de commit

## 4. Manejo de Errores

### Estrategias de Error Handling

```typescript
// ‚úÖ Manejo de errores en async operations
try {
  const { data, error } = await supabase
    .from('patients')
    .select('*')
    .eq('id', patientId)
    .single();

  if (error) throw error;
  
  // Usar data
} catch (error) {
  const message = error instanceof Error 
    ? error.message 
    : 'Error desconocido';
  toast.error(message);
  console.error('Error fetching patient:', error);
}
```

### Error Boundaries

- Crear componentes Error Boundary para capturar errores en componentes hijos
- Implementar fallback UI para errores
- Logging centralizado de errores (considerar Sentry para producci√≥n)

### Validaci√≥n de Input

- **Cliente**: Usar Zod + React Hook Form para validaci√≥n inmediata
- **Servidor**: Supabase RLS (Row Level Security) para validaci√≥n del servidor
- **Sanitizaci√≥n**: Supabase maneja esto autom√°ticamente, pero ser cuidadoso con HTML renderizado

## 5. Consideraciones de Performance

### Optimizaci√≥n de C√≥digo

- **Code Splitting**: Usar `React.lazy` y `Suspense` para componentes grandes
- **Memoizaci√≥n**: Usar `React.memo`, `useMemo`, `useCallback` cuando sea apropiado
- **Lazy Loading de Im√°genes**: Considerar lazy loading para im√°genes grandes
- **Evitar re-renders innecesarios**: Solo actualizar estado cuando sea necesario

```typescript
// ‚úÖ Lazy loading de componentes
import { lazy, Suspense } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));

const App = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <HeavyComponent />
  </Suspense>
);
```

### Optimizaci√≥n de Bundle

- **Tree Shaking**: Vite lo hace autom√°ticamente
- **An√°lisis de bundle**: Usar `vite-bundle-visualizer` si es necesario
- **Dependencias peque√±as**: Preferir librer√≠as ligeras

### Gesti√≥n de Memoria

- **Limpiar efectos**: Siempre limpiar event listeners y timers en `useEffect`
- **Evitar memory leaks**: No mantener referencias innecesarias
- **Estructuras inmutables**: No mutar datos directamente

```typescript
// ‚úÖ Limpieza en useEffect
useEffect(() => {
  const subscription = supabase
    .channel('patients')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'patients' }, handleChange)
    .subscribe();

  return () => {
    subscription.unsubscribe();
  };
}, []);
```

## 6. Seguridad

### Buenas Pr√°cticas de Seguridad

- **Variables de Entorno**: NUNCA commitear `.env` (ya en `.gitignore`)
- **Prefijo `VITE_`**: Usar `VITE_` para variables accesibles en cliente
- **RLS en Supabase**: Siempre configurar Row Level Security en tablas
- **Validaci√≥n**: Validar input en cliente Y servidor
- **HTTPS**: Usar HTTPS en producci√≥n (Vercel/Netlify lo hacen autom√°ticamente)

```typescript
// ‚úÖ Variables de entorno
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// ‚ùå NUNCA exponer secretos del servidor en cliente
// const SECRET_KEY = import.meta.env.SECRET_KEY; // ‚ùå INCORRECTO
```

### Autenticaci√≥n y Autorizaci√≥n

- **Supabase Auth**: Usar autenticaci√≥n de Supabase
- **Tokens seguros**: Supabase maneja tokens autom√°ticamente
- **RLS Policies**: Implementar pol√≠ticas de seguridad en Supabase
- **Protecci√≥n de rutas**: Usar `ProtectedRoute` para rutas privadas

### Protecci√≥n de Datos

- **Encriptaci√≥n**: Supabase maneja encriptaci√≥n en tr√°nsito y en reposo
- **Actualizar dependencias**: Mantener dependencias actualizadas
- **No exponer secretos**: Nunca exponer API keys o secretos en c√≥digo cliente

## 7. Testing (Futuro)

### Estrategias de Testing

Cuando se implemente testing:

- **Unit Tests**: Testear componentes individuales con Vitest + React Testing Library
- **Integration Tests**: Testear interacciones entre componentes
- **E2E Tests**: Considerar Playwright o Cypress para flujos cr√≠ticos
- **Mocking**: Usar MSW (Mock Service Worker) para mockear llamadas a Supabase

### Organizaci√≥n de Tests

- Co-locar tests con componentes: `Component.test.tsx`
- Agrupar por feature cuando sea apropiado
- Usar nombres descriptivos: `ComponentName.test.tsx`

## 8. Herramientas y Entorno

### Herramientas Recomendadas

- **VS Code**: Editor con extensiones para React/TypeScript
- **ESLint**: Ya configurado, ejecutar `npm run lint` antes de commit
- **Prettier**: Considerar agregar para formato autom√°tico
- **React Developer Tools**: Extensi√≥n del navegador para debugging
- **Supabase Dashboard**: Para gestionar base de datos y autenticaci√≥n

### Configuraci√≥n de Build

- **Vite**: Ya configurado, usar `npm run build` para producci√≥n
- **Variables de entorno**: Usar `.env.local` para desarrollo
- **Optimizaci√≥n**: Vite optimiza autom√°ticamente para producci√≥n

### Linting y Formato

- **ESLint**: Ejecutar `npm run lint` antes de hacer commit
- **TypeScript**: El compilador verifica tipos autom√°ticamente
- **Configuraci√≥n compartida**: Asegurar que todos usen la misma configuraci√≥n

## 9. Errores Comunes y C√≥mo Evitarlos

### Errores Frecuentes

1. **Olvidar dependencias en useEffect**:
   ```typescript
   // ‚ùå Incorrecto
   useEffect(() => {
     fetchData(userId);
   }, []); // Falta userId

   // ‚úÖ Correcto
   useEffect(() => {
     fetchData(userId);
   }, [userId]);
   ```

2. **No limpiar suscripciones**:
   ```typescript
   // ‚ùå Incorrecto
   useEffect(() => {
     const sub = supabase.channel('...').subscribe();
     // Falta cleanup
   }, []);

   // ‚úÖ Correcto
   useEffect(() => {
     const sub = supabase.channel('...').subscribe();
     return () => sub.unsubscribe();
   }, []);
   ```

3. **Mutaci√≥n directa de estado**:
   ```typescript
   // ‚ùå Incorrecto
   const updateList = (item) => {
     list.push(item); // Mutaci√≥n directa
   };

   // ‚úÖ Correcto
   const updateList = (item) => {
     setList([...list, item]); // Nueva referencia
   };
   ```

4. **No manejar estados de carga y error**:
   ```typescript
   // ‚ùå Incorrecto
   const { data } = useQuery({ ... });

   // ‚úÖ Correcto
   const { data, isLoading, error } = useQuery({ ... });
   if (isLoading) return <Loading />;
   if (error) return <Error message={error.message} />;
   ```

## 10. Checklist de Desarrollo

Antes de hacer commit:

- [ ] C√≥digo compila sin errores (`npm run build`)
- [ ] Linter pasa (`npm run lint`)
- [ ] Probado localmente (`npm run dev`)
- [ ] Tipos TypeScript correctos (sin `any` innecesarios)
- [ ] Sin `console.log` o c√≥digo de debug
- [ ] Manejo de errores implementado
- [ ] Estados de carga manejados (loading, error)
- [ ] Componentes son reutilizables cuando es apropiado
- [ ] Comentarios en c√≥digo complejo
- [ ] Variables de entorno documentadas si son nuevas
- [ ] Sin memory leaks (cleanup en useEffect)
- [ ] Dependencias correctas en hooks

## 11. Convenciones Espec√≠ficas del Proyecto

### Imports

```typescript
// 1. React y librer√≠as externas
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

// 2. Imports de alias (@/)
import { Button } from '@/components/ui/button';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';

// 3. Imports relativos (solo si es necesario)
import { Message } from '../types/health';
```

### Nombres de Variables

- **Variables**: `camelCase` - `patientName`, `isActive`
- **Funciones**: `camelCase` con verbos - `handleSubmit`, `fetchPatients`
- **Componentes**: `PascalCase` - `PatientCard`, `ChatMessage`
- **Constantes**: `UPPER_SNAKE_CASE` - `MAX_RETRIES`, `API_TIMEOUT`
- **Tipos/Interfaces**: `PascalCase` - `Patient`, `AuthContextType`

### Comentarios

- Comentar c√≥digo complejo, no lo obvio
- Usar JSDoc para funciones p√∫blicas:
  ```typescript
  /**
   * Fetches patient data from Supabase
   * @param patientId - The unique identifier of the patient
   * @returns Promise with patient data or null if not found
   */
  const fetchPatient = async (patientId: string) => { ... };
  ```

## 12. Integraci√≥n con Supabase

### Cliente de Supabase

```typescript
// ‚úÖ Siempre usar el cliente centralizado
import { supabase } from '@/integrations/supabase/client';

// ‚úÖ Usar tipos generados
import type { Database } from '@/integrations/supabase/types';
```

### Real-time Subscriptions

```typescript
// ‚úÖ Limpiar suscripciones correctamente
useEffect(() => {
  const channel = supabase
    .channel('patients-changes')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'patients' },
      (payload) => {
        // Manejar cambios
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(channel);
  };
}, []);
```

### Migraciones

- Las migraciones de Supabase est√°n en `supabase/migrations/`
- NO modificar migraciones ya aplicadas
- Crear nuevas migraciones para cambios de esquema
- Probar migraciones en desarrollo antes de producci√≥n
